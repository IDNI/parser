// This file is generated by 
//       https://github.com/IDNI/parser/tools/parser_gen
#include <string.h>
#include "parser.h"
struct tree_extraction {
	tree_extraction() :
		nts(load_nonterminals()), cc(load_cc()),
		g(nts, load_prods(), nt(17), cc), p(g, load_opts()) {}
	std::unique_ptr<typename idni::parser<char>::pforest> parse(
		const char* data, size_t size = 0,
		char eof = std::char_traits<char>::eof())
			{ return p.parse(data, size, eof); }
	std::unique_ptr<typename idni::parser<char>::pforest> parse(
		int fd, size_t size = 0,
		char eof = std::char_traits<char>::eof())
			{ return p.parse(fd, size, eof); }
	std::unique_ptr<typename idni::parser<char>::pforest> parse(
		std::basic_istream<char>& is,
		size_t size = 0,
		char eof = std::char_traits<char>::eof())
			{ return p.parse(is, size, eof); }
	bool found() { return p.found(); }
	typename idni::parser<char>::perror_t get_error()
		{ return p.get_error(); }
	size_t id(const std::basic_string<char>& name) { return nts.get(name); }
private:
	std::vector<char> ts{
		'\0', '=', '0', '1', 
	};
	idni::nonterminals<char> nts{};
	idni::char_class_fns<> cc;
	idni::grammar<char> g;
	idni::parser<char> p;
	idni::prods<char> t(size_t tid) {
		return idni::prods<char>(ts[tid]);
	}
	idni::prods<char> nt(size_t ntid) {
		return idni::prods<char>(idni::lit<char>(ntid, &nts));
	}
	idni::nonterminals<char> load_nonterminals() const {
		idni::nonterminals<char> nts{};
		for (const auto& nt : {
			"", "eof", "space", "digit", "xdigit", "alpha", "alnum", "punct", "printable", "chars", 
			"chars_0", "chars_1", "cbf_rule", "cbf_head", "cbf", "dot", "bf", "start", 
		}) nts.get(nt);
		return nts;
	}
	idni::char_class_fns<> load_cc() {
		return idni::predefined_char_classes<char>({
			"eof",
			"space",
			"digit",
			"xdigit",
			"alpha",
			"alnum",
			"punct",
			"printable",
		}, nts);
	}
	idni::parser<char>::options load_opts() {
		idni::parser<char>::options o;
		return o;
	}
	idni::prods<char> load_prods() {
		idni::prods<char> q, nul(idni::lit<char>{});
		// chars_0 => alnum.
		q(nt(10), (nt(6)));
		// chars_1 => chars_0 chars_1.
		q(nt(11), (nt(10)+nt(11)));
		// chars_1 => Îµ.
		q(nt(11), (nul));
		// chars => alpha chars_1.
		q(nt(9), (nt(5)+nt(11)));
		// cbf_rule => chars '=' cbf dot.
		q(nt(12), (nt(9)+t(1)+nt(14)+nt(15)));
		// cbf_rule => cbf_head.
		q(nt(12), (nt(13)));
		// cbf_head => cbf.
		q(nt(13), (nt(14)));
		// cbf => chars.
		q(nt(14), (nt(9)));
		// cbf => bf.
		q(nt(14), (nt(16)));
		// bf => '0'.
		q(nt(16), (t(2)));
		// bf => '1'.
		q(nt(16), (t(3)));
		// start => cbf_rule.
		q(nt(17), (nt(12)));
		return q;
	}
};
